/*
Copyright 2016 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package generators

import (
	"fmt"
	"io"
	"path/filepath"
	"strings"

	"github.com/golang/glog"

	"k8s.io/gengo/args"
	"k8s.io/gengo/generator"
	"k8s.io/gengo/namer"
	"k8s.io/gengo/types"
)

// NameSystems returns the name system used by the generators in this package.
func NameSystems() namer.NameSystems {
	return namer.NameSystems{
		"public": namer.NewPublicNamer(1),
		"raw":    namer.NewRawNamer("", nil),
	}
}

// DefaultNameSystem returns the default name system for ordering the types to be
// processed by the generators in this package.
func DefaultNameSystem() string {
	return "public"
}

type TypePath struct {
	Type string
	Path string
}

func Packages(context *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
	boilerplate, err := arguments.LoadGoBoilerplate()
	if err != nil {
		glog.Fatalf("Failed loading boilerplate: %v", err)
	}

	packages := generator.Packages{}
	header := append([]byte(fmt.Sprintf("// +build !%s\n\n", arguments.GeneratedBuildTag)), boilerplate...)
	header = append(header, []byte(`

// This file was autogenerated by nestedobj-gen. Do not edit it manually!

`)...)

	// We are generating defaults only for packages that are explicitly
	// passed as InputDir.
	for _, i := range context.Inputs {
		glog.V(5).Infof("considering pkg %q", i)
		pkg := context.Universe[i]
		if pkg == nil {
			// If the input had no Go files, for example.
			continue
		}

		packages = append(packages,
			&generator.DefaultPackage{
				PackageName: filepath.Base(pkg.Path),
				PackagePath: pkg.Path,
				HeaderText:  header,
				GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
					return []generator.Generator{
						NewGenNestedObj(arguments.OutputFileBaseName, pkg.Path, nil),
					}
				},
				FilterFunc: func(c *generator.Context, t *types.Type) bool {
					return t.Name.Package == pkg.Path
				},
			})
	}

	return packages
}

func hasInitContainer(t *types.Type) bool {
	for _, m := range t.Members {
		if m.Name == "InitContainers" {
			return true
		}

		t_ := m.Type
		if m.Type.Kind == types.Pointer {
			t_ = m.Type.Elem
		}

		if hasInitContainer(t_) {
			return true
		}
	}

	return false
}

func hasInitContainerAnnotation(t *types.Type) bool {
	return strings.HasSuffix(t.Name.Name, "PodTemplateSpec") ||
		strings.HasSuffix(t.Name.Name, "Pod")
}

func hasAnnotations(t *types.Type) bool {
	if hasInitContainerAnnotation(t) {
		return true
	}

	for _, m := range t.Members {
		if hasInitContainerAnnotation(t) {
			return true
		}

		t_ := m.Type
		if m.Type.Kind == types.Pointer {
			t_ = m.Type.Elem
		}

		if hasAnnotations(t_) {
			return true
		}
	}

	return false
}

func getInitContainerPath(t *types.Type, initContainer *string) bool {
	for _, m := range t.Members {
		if m.Name == "InitContainers" {
			return true
		}

		path := *initContainer
		path = path + "." + m.Name

		t_ := m.Type
		if m.Type.Kind == types.Pointer {
			t_ = m.Type.Elem
		}

		if getInitContainerPath(t_, &path) {
			*initContainer = path
			return true
		}
	}

	return false
}

func getAnnotationPath(t *types.Type, annotation *string) bool {
	for _, m := range t.Members {
		path := *annotation
		path = path + "." + m.Name

		if strings.HasSuffix(m.Type.Name.Name, "PodTemplateSpec") ||
			strings.HasSuffix(m.Type.Name.Name, "Pod") {
			*annotation = path
			return true
		}

		t_ := m.Type
		if m.Type.Kind == types.Pointer {
			t_ = m.Type.Elem
		}

		if getAnnotationPath(t_, &path) {
			*annotation = path
			return true
		}
	}

	return false
}

// genNestedObj produces a file with a autogenerated nested objects.
type genNestedObj struct {
	generator.DefaultGen

	targetPackage string
	peerPackages  []string
	imports       namer.ImportTracker
	typesForInit  []*types.Type
}

func NewGenNestedObj(sanitizedName, targetPackage string, peerPkgs []string) generator.Generator {
	return &genNestedObj{
		DefaultGen: generator.DefaultGen{
			OptionalName: sanitizedName,
		},
		targetPackage: targetPackage,
		peerPackages:  peerPkgs,
		imports:       generator.NewImportTracker(),
		typesForInit:  make([]*types.Type, 0),
	}
}

func (g *genNestedObj) Namers(c *generator.Context) namer.NameSystems {
	// Have the raw namer for this file track what it imports.
	return namer.NameSystems{
		"raw": namer.NewRawNamer(g.targetPackage, g.imports),
	}
}

func (g *genNestedObj) isOtherPackage(pkg string) bool {
	if pkg == g.targetPackage {
		return false
	}
	if strings.HasSuffix(pkg, `"`+g.targetPackage+`"`) {
		return false
	}
	return true
}

func (g *genNestedObj) Filter(c *generator.Context, t *types.Type) bool {
	return hasInitContainer(t) && hasAnnotations(t)
}

func (g *genNestedObj) Imports(c *generator.Context) []string {
	var importLines []string = []string{
		"k8s.io/apimachinery/pkg/runtime",
		"encoding/json",
	}

	return importLines
}

func (g *genNestedObj) Init(c *generator.Context, w io.Writer) error {
	return nil
}

func (g *genNestedObj) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
	var annotationPath, initContainerPath string

	getInitContainerPath(t, &initContainerPath)
	getAnnotationPath(t, &annotationPath)

	sw := generator.NewSnippetWriter(w, c, "$", "$")

	sw.Do(`
	func (t *$.inType$) DecodeNestedObjects(d runtime.Decoder) error {`, generator.Args{
		"inType": t.Name.Name,
	})

	checkNilPtr(sw, t, initContainerPath)

	sw.Do(`
		if value, ok := t$.inAnn$.Annotations["pod.beta.kubernetes.io/init-containers"]; ok {
			if err := json.Unmarshal([]byte(value), &t$.inPath$.InitContainers); err != nil {
				return err
			}
		}

		if value, ok := t$.inAnn$.Annotations["pod.alpha.kubernetes.io/init-containers"]; ok {
			if err := json.Unmarshal([]byte(value), &t$.inPath$.InitContainers); err != nil {
				return err
			}
		}
		return nil`, generator.Args{
		"inAnn":  annotationPath,
		"inPath": initContainerPath,
	})

	sw.Do(`
	}
	`, generator.Args{})

	return sw.Error()
}

func checkNilPtr(sw *generator.SnippetWriter, t_ *types.Type, path string) {
	items := strings.Split(path, ".")

	t := t_

	var itemPath string = "t"

	for _, item := range items {
		if len(item) == 0 {
			continue
		}
		itemPath = fmt.Sprintf("%s.%s", itemPath, item)
		for _, m := range t.Members {
			if m.Name == item {
				if m.Type.Kind == types.Pointer {
					sw.Do(`
					if $.itemPath$ == nil {
						return nil
					}
					`, generator.Args{"itemPath":itemPath})
				}
				t = m.Type
				break
			}
		}
	}
}
